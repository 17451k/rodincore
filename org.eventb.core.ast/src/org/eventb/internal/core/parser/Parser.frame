/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

*File modified by François Terrier and Laurent Voisin (ETH Zürich)*

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin

/**
 *  Implements a parser for the Event-B mathematical language.
 */
@SuppressWarnings("deprecation")
public class Parser {
-->constants
	static final boolean T = true;
	static final boolean x = false;
	static final int minErrDist = 2;

	// Internal exception class for fast error recovery of the parser.
	private class ParserException extends RuntimeException {
		private static final long serialVersionUID = -1336579865793161268L;
		ParserException(String msg) {
			super(msg);
		}
	}

	protected Token t;    // last recognized token
	protected Token la;   // lookahead token
	int errDist = minErrDist;
	
	private final Scanner scanner;
	
	// this field configures the parser to parse some kind of formula,
	// viz. Expression, Predicate, Assignment, or Type.
	private final Class<?> clazz;
	
	private final ParseResult result;
	private final FormulaFactory factory;
	private final LanguageVersion version;
	
	/**
	 * Returns the current parsing result.
	 *
	 * @return the current result.
	 */
	public ParseResult getResult() {
		return result;
	}
	
	-->declarations

	/**
	 * Creates a new parser that reads tokens produced by
	 * <code>scanner</code> and creates the resulting Abstract Syntax Tree.
	 * The outcome of both scanning and parsing is stored in the given result.
	 * 
	 * @param clazz Formula class that this parser recognises
	 * @param scanner the scanner to get input tokens from
	 * @param result the result of scan and parse
	 */
	public Parser(Class<?> clazz, Scanner scanner, ParseResult result) {
		this.scanner = scanner;
		this.factory = result.factory;
		this.clazz = clazz;
		this.result = result;
		this.version = result.version;
		
	    assert (clazz == Predicate.class ||
	    		clazz == Expression.class ||
	    		clazz == Assignment.class ||
	    		clazz == Type.class);
	}

	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	boolean StartOf (int s) {
		return set[s][la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	boolean WeakSeparator (int n, int syFol, int repFol) {
		boolean[] s = new boolean[maxT+1];
		if (la.kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			for (int i=0; i <= maxT; i++) {
				s[i] = set[syFol][i] || set[repFol][i] || set[0][i];
			}
			SynErr(n);
			while (!s[la.kind]) Get();
			return StartOf(syFol);
		}
	}
	
-->productions

	/**
	 * Parses the tokens produced by the scanner associated to this parser.
	 * <p>
	 * The actual result of the parse is obtained via
	 * {@link #getResult() getResult()}.
	 */
	public void Parse() {
		try {
			la = new Token(_EOF, "");
			Get();
-->parseRoot
			Expect(0);
		}
		catch (ParserException e) {
			result.resetParsedFormula();
		}
	}

	private boolean[][] set = {
-->initialization
	};

	void SynErr (int n) {
		if (errDist >= minErrDist) {
			String s;
			switch (n) {-->errors
				default: s = "error " + n; break;
			}
			SourceLocation loc = new SourceLocation(la.pos,
					la.pos + la.val.length(), result.getOrigin());
			result.addProblem(new ASTProblem(loc, ProblemKind.SyntaxError,
					ProblemSeverities.Error, s));
			throw new ParserException(s);
		}
		errDist = 0;
	}
	
	// For testing purposes
	public static int getMaxT() {
		return maxT;
	}
	
} // end Parser

$$$