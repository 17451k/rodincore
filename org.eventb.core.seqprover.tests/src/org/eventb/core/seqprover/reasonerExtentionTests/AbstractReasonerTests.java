package org.eventb.core.seqprover.reasonerExtentionTests;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import junit.framework.TestCase;

import org.eventb.core.ast.Expression;
import org.eventb.core.ast.Predicate;
import org.eventb.core.seqprover.IProofRule;
import org.eventb.core.seqprover.IProofTree;
import org.eventb.core.seqprover.IProverSequent;
import org.eventb.core.seqprover.IReasoner;
import org.eventb.core.seqprover.IReasonerFailure;
import org.eventb.core.seqprover.IReasonerInput;
import org.eventb.core.seqprover.IReasonerInputReader;
import org.eventb.core.seqprover.IReasonerInputWriter;
import org.eventb.core.seqprover.IReasonerOutput;
import org.eventb.core.seqprover.ITactic;
import org.eventb.core.seqprover.ProverFactory;
import org.eventb.core.seqprover.SequentProver;
import org.eventb.core.seqprover.SerializeException;
import org.eventb.core.seqprover.IProofRule.IAntecedent;
import org.eventb.internal.core.seqprover.ProverChecks;
import org.junit.Before;
import org.junit.Test;

/**
 * An abstract class that can be extended in order to be used to test reasoner extensions.
 * 
 * <p>
 * Tests performed include :
 * <ul>
 * <li> Registry entry tests
 * <li> Reasoner failure tests
 * <li> Reasoner success tests (including input serialization tests, replay tests, and optional logical justification tests)
 * </ul>
 * </p>
 * 
 * 
 * @author Farhad Mehta
 *
 */
public abstract class AbstractReasonerTests extends TestCase {


	/**
	 * Returns the reasoner id of the reasoner to test
	 * 
	 * @return the reasoner id of the reasoner to test
	 * 		
	 */
	public abstract String getReasonerID();
	
	/**
	 * Returns the successful reasoner applications to test
	 * 
	 * @return the successful reasoner applications to test
	 */
	public abstract SuccessfullReasonerApplication[] getSuccessfulReasonerApplications();
	
	/**
	 * Returns the unsuccessful reasoner applications to test
	 * 
	 * @return the unsuccessful reasoner applications to test
	 */
	public abstract UnsuccessfullReasonerApplication[] getUnsuccessfullReasonerApplications();
	

	/**
	 * Returns the tactic that should be used to test that the justifications for the rules
	 * generated by the reasoner are valid.
	 * 
	 * <p>
	 * By default this method returns <code>null</code> and rule justifications are not tested 
	 * for validity. Clients that wish to do this may override this method with their tactic of
	 * choice.
	 * </p>
	 * 
	 * <p>
	 * This method of testing generated proof rules for validity is intended to be used more as logical debugging
	 * support than to be used in regular reasoner unit tests.
	 * </p>
	 * 
	 * @return the tactic to use to discharge the justifications of all rules created by this test case.
	 * 
	 */
	public ITactic getJustDischTactic(){
		return null;
	}
	
	private IReasoner reasoner;
	
	@Override
	@Before
	protected void setUp() throws Exception {
		super.setUp();
		// Setup needs to be done only once since reasoner is not modified.
		if (reasoner == null)
		{ 
			assertTrue("Reasoner with id " + getReasonerID() + "is not registered",
					SequentProver.getReasonerRegistry().isRegistered(getReasonerID()));
			reasoner = SequentProver.getReasonerRegistry().getReasonerInstance(getReasonerID());
			assertFalse("Reasoner with id " + getReasonerID() + "is a dummy reasoner.",
					SequentProver.getReasonerRegistry().isDummyReasoner(reasoner));

		}
	}
	
	/**
	 * Tests that the entry for the reasoner in the reasoner registry is correct.
	 */
	@Test
	public final void testReasonerRegistryEntry(){
		assertEquals("Reasoner ID from registry is not identical to the reasoner ID returned by the reasoner",
				getReasonerID(), reasoner.getReasonerID());
	}
	
	
	/**
	 * Tests the correct failure of the reasoner.
	 */
	@Test
	public final void testReasonerFailure(){
		UnsuccessfullReasonerApplication[] reasonerApplications = getUnsuccessfullReasonerApplications();
		for (UnsuccessfullReasonerApplication reasonerApp : reasonerApplications) {
			IReasonerOutput output = reasoner.apply(reasonerApp.getSequent(), reasonerApp.getInput(), null);
			assertTrue("Reasoner Application (" + reasonerApp.toString() + ") did not result in failure.",
					output instanceof IReasonerFailure);
			if (reasonerApp.getReason() != null){
				assertEquals("Reason for reasoner application failure for (" + reasonerApp.toString() + ") is not as expected.",
						reasonerApp.getReason(), ((IReasonerFailure)output).getReason());
			}
		}
		
	}
	
	/**
	 * Tests the correct succcess of the reasoner and the rules generated generated by it.
	 */
	@Test
	public final void testReasonerSuccess(){
		SuccessfullReasonerApplication[] reasonerApplications = getSuccessfulReasonerApplications();
		for (SuccessfullReasonerApplication reasonerApp : reasonerApplications) {
			
			IProofRule rule = testReasonerSuccessHelper(reasonerApp);
			
			// Test proper serialization and deserialization of the rule
			ReasonerInputSerializer serializer = new ReasonerInputSerializer(rule);
			IReasonerInput deserializedInput = null;
			try {
				reasoner.serializeInput(reasonerApp.getInput(), serializer);
				deserializedInput = reasoner.deserializeInput(serializer);
			} catch (SerializeException e) {
				// This should not happen.
				fail();
			}
			
			assertNotNull(deserializedInput);
			assertFalse("Deserialized input for (" + reasonerApp.toString() + ") has an error",
					deserializedInput.hasError());
			assertTrue("Deserialized input class not equal to original class for (" + reasonerApp.toString(),
					deserializedInput.getClass().equals(reasonerApp.getInput().getClass()));
			
			// Test that deserialized version of the input behaves in the same way as the original input.
			// (At the moment the only way to do this is with a replay)
			testReasonerSuccessHelper(new SuccessfullReasonerApplication(
					reasonerApp.getSequent(),deserializedInput,reasonerApp.getNewSequents()));
			
			// Test that reasoner justifications can be discharged by the given tactic.
			if (getJustDischTactic() != null){
				List<IProverSequent> justfs = ProverChecks.genRuleJustifications(rule);
				for (IProverSequent just : justfs) {
					IProofTree proofTree = ProverFactory.makeProofTree(just, null);
					getJustDischTactic().apply(proofTree.getRoot(), null);
					assertTrue("Justificaton "+ just + " for rule generated by (" + reasonerApp.toString() + 
							") could not be discharged using the given tactic",
							proofTree.isClosed());
				}
			}
		}
	}

	/**
	 * Helper method for {@link #testReasonerSuccess()}.
	 * 
	 * Generates a rule from the reasoner application object and performs tests on it.
	 * 
	 * @param reasonerApp
	 * @return
	 */
	private IProofRule testReasonerSuccessHelper(SuccessfullReasonerApplication reasonerApp) {
		IReasonerOutput output = reasoner.apply(reasonerApp.getSequent(), reasonerApp.getInput(), null);
		assertTrue("Reasoner Application (" + reasonerApp.toString() + ") did not result in success.",
				output instanceof IProofRule);
		
		// Perform tests on the generated rule.
		IProofRule rule = ((IProofRule)output);
		assertTrue("Rule generated by reasoner application (" + reasonerApp.toString() + ") did not pass prover checks",
				ProverChecks.checkRule(rule));
		IProverSequent[] newSeqs = rule.apply(reasonerApp.getSequent());
		assertNotNull("Rule generated by reasoner application (" + reasonerApp.toString() + ") could not be applied to its sequent",
				newSeqs);
		if (reasonerApp.getNewSequents() != null){
			assertEquals("Generated new sequents for (" + reasonerApp.toString() + ") are not as expected.",
					reasonerApp.getNewSequents(), Arrays.toString(newSeqs));
		}
		return rule;
	}



	/**
	 * This class contains the inputs to the {@link IReasoner#apply()} method and its expected result.
	 * 
	 * @author Farhad Mehta
	 *
	 */
	private static class ReasonerApplication{
		
		final IProverSequent sequent;
		final IReasonerInput input;
		
		/**
		 * Constructs a new {@link ReasonerApplication} instance. 
		 * 
		 * @param sequent
		 * 		the sequent to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param input
		 * 		the reasoner input to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 */
		protected ReasonerApplication(final IProverSequent sequent, final IReasonerInput input) {
			super();
			this.sequent = sequent;
			this.input = input;
		}

		/**
		 * @return the input
		 */
		public IReasonerInput getInput() {
			return input;
		}

		/**
		 * @return the sequent
		 */
		public IProverSequent getSequent() {
			return sequent;
		}
		
		public String toString(){
			return "Sequent: " + sequent.toString() + ", Input: " + input.toString();
		}
		
	}
	
	/**
	 * This class contains the inputs to a successfull call to the {@link IReasoner#apply()} method 
	 * and its expected result.
	 * 
	 * @author Farhad Mehta
	 *
	 */
	public static class SuccessfullReasonerApplication extends ReasonerApplication{
		
		final private String newSequents;
		
		/**
		 * Constructs a new {@link SuccessfullReasonerApplication} instance with expected new sequents.
		 * 
		 * @param sequent
		 * 		the sequent to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param input
		 * 		the reasoner input to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param newSequents
		 * 		the string version of the array of new sequents obtained by applying the rule generated by the reasoner
		 * 		application on the given sequent, or <code>null</code> in case this check should not be performed. 
		 */
		public SuccessfullReasonerApplication(IProverSequent sequent, IReasonerInput input, String newSequents) {
			super(sequent, input);
			this.newSequents = newSequents;
		}
		
		/**
		 * Constructs a new {@link SuccessfullReasonerApplication} instance without expected new sequents.
		 * 
		 * @param sequent
		 * 		the sequent to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param input
		 * 		the reasoner input to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 */
		public SuccessfullReasonerApplication(IProverSequent sequent, IReasonerInput input) {
			super(sequent, input);
			this.newSequents = null;
		}

		/**
		 * @return the string version of the array of new sequents obtained by applying the rule generated by the reasoner
		 * 		application on the given sequent, or <code>null</code> in case this check should not be performed.
		 * 
		 */
		public String getNewSequents() {
			return newSequents;
		}
		
		public String toString(){
			return super.toString();
		}		
		
	}
	
	/**
	 * This class contains the inputs to an unsuccessfull call to the {@link IReasoner#apply()} method 
	 * and its expected result.
	 * 
	 * @author Farhad Mehta
	 *
	 */
	public static class UnsuccessfullReasonerApplication extends ReasonerApplication{
		
		final private String reason;
		
		/**
		 * Constructs a new {@link UnsuccessfullReasonerApplication} instance with expected reason.
		 * 
		 * @param sequent
		 * 		the sequent to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param input
		 * 		the reasoner input to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param reason
		 * 		the expected reason for reasoner failure, or <code>null</code> in case this check should not be performed. 
		 */
		public UnsuccessfullReasonerApplication(IProverSequent sequent, IReasonerInput input, String reason) {
			super(sequent, input);
			this.reason = reason;
		}

		/**
		 * Constructs a new {@link UnsuccessfullReasonerApplication} instance without an expected reason.
		 * 
		 * @param sequent
		 * 		the sequent to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 * @param input
		 * 		the reasoner input to use as input to the {@link IReasoner#apply()} method (non <code>null</code>)
		 */
		public UnsuccessfullReasonerApplication(IProverSequent sequent, IReasonerInput input) {
			super(sequent, input);
			this.reason = null;
		}
		
		/**
		 * @return the expected reason for reasoner failure, or <code>null</code> in case no such check should not be performed.
		 */
		public String getReason() {
			return reason;
		}
		
		public String toString(){
			return super.toString();
		}		
		
	}
	
	/**
	 * Trivial implementation for reasoner serialisation tests.
	 * 
	 * @author Farhad Mehta
	 *
	 */
	private static class ReasonerInputSerializer implements IReasonerInputReader, IReasonerInputWriter{

		private final IProofRule rule;
		private final Map<String, Predicate[]> predicates;
		private final Map<String, Expression[]> expressions;
		private final Map<String, String> strings;

		public ReasonerInputSerializer(IProofRule rule) {
			this.rule = rule;
			this.predicates = new HashMap<String, Predicate[]>();
			this.expressions = new HashMap<String, Expression[]>();
			this.strings = new HashMap<String, String>();
		}

		public IAntecedent[] getAntecedents() {
			return rule.getAntecedents();
		}

		public int getConfidence() {
			return rule.getConfidence();
		}

		public String getDisplayName() {
			return rule.getDisplayName();
		}

		public Expression[] getExpressions(String key) throws SerializeException {
			return expressions.get(key);
		}

		public Predicate getGoal() {
			return rule.getGoal();
		}

		public Set<Predicate> getNeededHyps() {
			return rule.getNeededHyps();
		}

		public Predicate[] getPredicates(String key) throws SerializeException {
			return predicates.get(key);
		}

		public String getString(String key) throws SerializeException {
			return strings.get(key);
		}

		public void putExpressions(String key, Expression... exprs) throws SerializeException {
			expressions.put(key, exprs);	
		}

		public void putPredicates(String key, Predicate... preds) throws SerializeException {
			predicates.put(key,preds);
		}

		public void putString(String key, String str) throws SerializeException {
			strings.put(key, str);
		}
	}
	

}
