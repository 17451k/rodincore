/*******************************************************************************
 * Copyright (c) 2009 Systerel and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Systerel - initial API and implementation
 *******************************************************************************/
package org.rodinp.internal.core;

import java.util.Arrays;

/**
 * Utility class for generating unique names for database elements.
 * <p>
 * To ensure efficient use of space in XML files, the names generated by the
 * Rodin database should only consist of characters in range
 * <code>#x27-#x7E</code>, except the "<" sign.  This choice ensures that each
 * character will take exactly one byte in the UTF-8 encoded XML file.
 * </p>
 * 
 * @author Laurent Voisin
 */
public class NameGenerator {

	public static final char FIRST_CHAR = 0x27;
	public static final char LESS_THAN_SIGN = 0x3c;
	public static final char LAST_CHAR = 0x7e;

	// Greatest name already used by the database
	private String greatest = "";

	public void addUsedName(String s) {
		if (isValid(s) && greatest.compareTo(s) < 0) {
			greatest = s;
		}
	}

	public static boolean isValid(String s) {
		boolean result = true;
		for (int i = 0; result && i < s.length(); i++) {
			final char c = s.charAt(i);
			if (c > LAST_CHAR || c < FIRST_CHAR || c == LESS_THAN_SIGN)
				result = false;
		}
		return result;
	}

	public String advance() {
		final char[] tab = greatest.toCharArray();
		if (advance(tab)) {
			greatest = new String(tab);
		} else {
			final char[] newTab = new char[tab.length + 1];
			Arrays.fill(newTab, FIRST_CHAR);
			greatest = new String(newTab);
		}
		return greatest;
	}

	private static boolean advance(char[] tab) {
		for (int i = tab.length - 1; 0 <= i; --i) {
			if (tab[i] == LAST_CHAR) {
				tab[i] = FIRST_CHAR;
			} else {
				char c = ++tab[i];
				if (c == LESS_THAN_SIGN) {
					++tab[i];
				}
				return true;
			}
		}
		return false;
	}

}
